import { IMAGES_TYPE, SYSTEM_PROMPT_BASE } from '@/constants/story-images.constant';
import { mapAspectRatio } from '@/lib/image-layout';
import { supabase } from '@/supabaseClient';
import { StoryScenes } from '@/types';
import { getImageProviderConfig, ImageProviderConfig, ImageProviderId } from './imageProviderConfig';

type ImageProviderUsed = 'gemini' | 'openai' | 'manual_upload' | 'normalized_storage' | 'legacy_storage';

type ImageType = (typeof IMAGES_TYPE)[keyof typeof IMAGES_TYPE];

interface ImageGenerationOptions {
  storyId: string;
  chapterId?: string | number;
  scenes: StoryScenes; // Scenes generated by AI stored in DB
}

export interface GeneratedImageMetadata {
  providerUsed?: ImageProviderUsed;
  fallbackUsed?: boolean;
  latencyMs?: number;
  requestedAspectRatio?: string | null;
  effectiveAspectRatio?: string | null;
  requestSize?: string | null;
  originalResolution?: string | null;
  finalResolution?: string | null;
  resizedFrom?: string | null;
  resizedTo?: string | null;
  mimeType?: string | null;
  storagePath?: string | null;
  storyId?: string | null;
  chapterId?: string | null;
  imageType?: string | null;
}

interface GeneratedImage {
  type: ImageType;
  url: string;
  prompt: string;
  base64?: string;
  metadata?: GeneratedImageMetadata;
}

export interface ImageGenerationSummary {
  requestedAspectRatio: string;
  resolvedAspectRatio: string;
  fallbackApplied: boolean;
  defaultProvider: ImageProviderId;
  fallbackProvider: ImageProviderId;
}

interface ImageGenerationResult {
  success: boolean;
  images: GeneratedImage[];
  error?: string;
  errors?: string[];
  summary: ImageGenerationSummary;
  metadataByType?: Partial<Record<ImageType, GeneratedImageMetadata>>;
}

interface EdgeFunctionMetadata {
  providerUsed?: ImageProviderUsed;
  fallbackUsed?: boolean;
  latencyMs?: number;
  requestedAspectRatio?: string | null;
  effectiveAspectRatio?: string | null;
  requestSize?: string | null;
  originalResolution?: string | null;
  finalResolution?: string | null;
  resizedFrom?: string | null;
  resizedTo?: string | null;
  mimeType?: string | null;
  storagePath?: string | null;
  storyId?: string | null;
  chapterId?: string | null;
  imageType?: string | null;
}

interface EdgeFunctionResponse {
  success?: boolean;
  publicUrl?: string | null;
  storagePath?: string | null;
  metadata?: EdgeFunctionMetadata | null;
  providerUsed?: ImageProviderUsed;
  fallbackUsed?: boolean;
  latencyMs?: number;
  imageBase64?: string | null;
  error?: string;
}

interface GenerateSingleImageParams {
  imageType: ImageType;
  prompt: string;
  storyId: string;
  chapterId: string | number;
  providerConfig: ImageProviderConfig;
  desiredAspectRatio: string;
  logPrefix?: string;
}

/**
 * Secure service for generating story images using Supabase Edge Function
 * All OpenAI API keys are stored securely in Supabase secrets
 */
export class ImageGenerationService {
  /**
   * Generates all story images using AI-provided prompts from database
   * @param options Image generation options with scenes from database
   * @returns Promise with generation results
   */
  static async generateStoryImages(options: ImageGenerationOptions): Promise<ImageGenerationResult> {
    const { storyId, chapterId = 1, scenes } = options;

    const providerConfig = getImageProviderConfig();
    const ratioInfo = mapAspectRatio(providerConfig.desiredAspectRatio);
    const summary: ImageGenerationSummary = {
      requestedAspectRatio: ratioInfo.requested,
      resolvedAspectRatio: ratioInfo.resolved,
      fallbackApplied: ratioInfo.isFallback,
      defaultProvider: providerConfig.defaultProvider,
      fallbackProvider: providerConfig.fallbackProvider,
    };

    try {
      console.log(
        `[ImageGeneration] Starting image generation for story ${storyId}. Providers: default=${summary.defaultProvider}, fallback=${summary.fallbackProvider}`,
      );
      console.log(
        `[ImageGeneration] Desired aspect ratio ${summary.requestedAspectRatio} → resolved ${summary.resolvedAspectRatio}${summary.fallbackApplied ? ' (fallback applied)' : ''}`,
      );

      const baseQueue: ImageType[] = [
        IMAGES_TYPE.COVER,
        IMAGES_TYPE.SCENE_1,
        IMAGES_TYPE.SCENE_2,
        IMAGES_TYPE.SCENE_3,
        IMAGES_TYPE.SCENE_4,
        IMAGES_TYPE.CLOSING,
      ];
      const hasCharacterPrompt = typeof scenes.character === 'string' && scenes.character.trim().length > 0;
      const imageTypes: ImageType[] = hasCharacterPrompt ? [...baseQueue, IMAGES_TYPE.CHARACTER] : baseQueue;
      const successfulImages: GeneratedImage[] = [];
      const errors: string[] = [];
      const metadataByType: Partial<Record<ImageType, GeneratedImageMetadata>> = {};
      
      const promptMap: Partial<Record<ImageType, string>> = {
        [IMAGES_TYPE.COVER]: scenes.cover,
        [IMAGES_TYPE.SCENE_1]: scenes.scene_1,
        [IMAGES_TYPE.SCENE_2]: scenes.scene_2,
        [IMAGES_TYPE.SCENE_3]: scenes.scene_3,
        [IMAGES_TYPE.SCENE_4]: scenes.scene_4,
        [IMAGES_TYPE.CLOSING]: scenes.closing,
        ...(hasCharacterPrompt ? { [IMAGES_TYPE.CHARACTER]: scenes.character.trim() } : {}),
      };
      
      // Limited concurrency pool to reduce wall time and avoid rate limits
      const concurrency = 3;
      const queue: ImageType[] = [...imageTypes];
      const totalToProcess = queue.length;
      
      const worker = async () => {
        while (queue.length > 0) {
          const imageType = queue.shift();
          if (!imageType) return;
          try {
            const prompt = promptMap[imageType];
            if (!prompt) {
              const missingPromptMessage = `Missing prompt for ${imageType}`;
              errors.push(`${imageType}: ${missingPromptMessage}`);
              console.warn(`[ImageGeneration] ⚠️ ${missingPromptMessage}`);
              continue;
            }

            console.log(`[ImageGeneration] Generating ${imageType} with desired ratio ${summary.requestedAspectRatio}`);

            const result = await this.generateSingleImageWithFallback({
              imageType,
              prompt,
              storyId,
              chapterId,
              providerConfig,
              desiredAspectRatio: summary.requestedAspectRatio,
              logPrefix: `[ImageGeneration:${imageType}]`,
            });

            if (result.success && result.image) {
              successfulImages.push(result.image);
              const metadata = result.image.metadata;
              if (metadata) {
                metadataByType[imageType] = metadata;
                const requested = metadata.requestedAspectRatio ?? summary.requestedAspectRatio;
                const effective = metadata.effectiveAspectRatio ?? summary.resolvedAspectRatio;
                const provider = metadata.providerUsed ?? 'desconocido';
                console.log(
                  `[ImageGeneration] ✅ ${imageType} provider=${provider} ratio ${requested} → ${effective}${metadata.fallbackUsed ? ' (fallback)' : ''}`,
                );
              } else {
                console.log(`[ImageGeneration] ✅ Successfully generated ${imageType}`);
              }
            } else {
              errors.push(`${imageType}: ${result.error || 'Failed to generate'}`);
              console.warn(`[ImageGeneration] ⚠️ Failed to generate ${imageType}: ${result.error || 'Unknown error'}`);
            }
          } catch (error) {
            const errorMsg = error instanceof Error ? error.message : 'Unknown error';
            errors.push(`${imageType}: ${errorMsg}`);
            console.error(`[ImageGeneration] ❌ Error generating ${imageType}:`, error);
          }
        }
      };
      
      await Promise.all(Array.from({ length: Math.min(concurrency, queue.length || 1) }, () => worker()));
      successfulImages.sort((a, b) => imageTypes.indexOf(a.type) - imageTypes.indexOf(b.type));
      
      console.log(
        `[ImageGeneration] Completed: ${successfulImages.length}/${totalToProcess} images successful`,
      );
      
      return {
        success: successfulImages.length > 0,
        images: successfulImages,
        error: errors.length > 0 ? `Algunas imágenes fallaron: ${errors.join('; ')}` : undefined,
        errors: errors.length > 0 ? errors : undefined,
        summary,
        metadataByType: Object.keys(metadataByType).length > 0 ? metadataByType : undefined,
      };
      
    } catch (error) {
      console.error('[ImageGeneration] Critical error:', error);
      return {
        success: false,
        images: [],
        error: error instanceof Error ? error.message : 'Error crítico en generación de imágenes',
        errors: [error instanceof Error ? error.message : 'Error crítico en generación de imágenes'],
        summary,
      };
    }
  }

  /**
   * DEPRECATED: This method is no longer used. Prompts are now generated by story AI.
   * Keeping for reference only. Can be removed in future cleanup.
   * @deprecated Use AI-generated prompts from database instead
   */
  private static createOptimizedImagePrompts(title: string, content: string): Partial<Record<ImageType, string>> {
    // Extract key elements for visual consistency
    const contentSummary = this.extractStoryElements(content);
    
    // Enhanced base style with consistency instructions
    const baseStyle = `Estilo acuarela tradicional infantil, colores suaves y cálidos, técnica de acuarela con bordes difuminados, paleta de colores pasteles, fondo luminoso, ambiente mágico y acogedor.

IMPORTANTE: Mantener consistencia visual - ${contentSummary.character} debe aparecer con las mismas características físicas en todas las imágenes (mismos colores, rasgos, vestimenta básica). El ${contentSummary.setting} debe mantener la misma paleta de colores y estilo arquitectónico/natural.`;

    // Base context with full story content but optimized structure
    const storyContext = `**Contexto del Cuento:**
Título: "${title}"
Personaje Principal: ${contentSummary.character}
Escenario: ${contentSummary.setting}
Ambiente: ${contentSummary.mood}

**Historia Completa:**
${content}`;

    return {
      [IMAGES_TYPE.COVER]: `${SYSTEM_PROMPT_BASE}

${storyContext}

**INSTRUCCIONES PARA PORTADA:**
Genera una imagen de PORTADA que capture la esencia del cuento. Debe incluir el título "${title}" de manera artística y elementos visuales que representen la historia principal. El ${contentSummary.character} debe ser prominente y establecer el estilo visual que se mantendrá en las escenas.

${baseStyle}`,

      [IMAGES_TYPE.SCENE_1]: `${SYSTEM_PROMPT_BASE}

${storyContext}

**INSTRUCCIONES PARA PRIMERA ESCENA:**
Genera una imagen de la PRIMERA ESCENA más importante del cuento, donde el ${contentSummary.character} debe ser el elemento central de la composición. Muestra un momento clave de la historia con el protagonista en acción, MANTENIENDO EXACTAMENTE las mismas características visuales establecidas (colores, rasgos físicos, vestimenta).

${baseStyle}`,

      [IMAGES_TYPE.SCENE_2]: `${SYSTEM_PROMPT_BASE}

${storyContext}

**INSTRUCCIONES PARA SEGUNDA ESCENA:**
Genera una imagen de la SEGUNDA ESCENA más importante del cuento, donde el ${contentSummary.character} debe ser prominente. Representa otro momento crucial diferente al anterior, mostrando al protagonista en una situación distinta pero MANTENIENDO PERFECTAMENTE las características visuales establecidas en las imágenes anteriores.

${baseStyle}`,

      [IMAGES_TYPE.SCENE_3]: `${SYSTEM_PROMPT_BASE}

${storyContext}

**INSTRUCCIONES PARA TERCERA ESCENA:**
Genera una imagen de la TERCERA ESCENA importante del cuento. El ${contentSummary.character} debe continuar siendo el foco principal. Ilustra un momento de desarrollo o giro en la historia, MANTENIENDO EXACTAMENTE la misma apariencia del personaje y estilo visual de las escenas anteriores.

${baseStyle}`,

      [IMAGES_TYPE.SCENE_4]: `${SYSTEM_PROMPT_BASE}

${storyContext}

**INSTRUCCIONES PARA CUARTA ESCENA:**
Genera una imagen de la ESCENA FINAL o desenlace del cuento. El ${contentSummary.character} debe aparecer en el momento culminante o conclusión de la historia. Mantén perfecta consistencia visual con todas las imágenes anteriores, mostrando la resolución del cuento de forma visualmente satisfactoria.

${baseStyle}`,

      [IMAGES_TYPE.CLOSING]: `${SYSTEM_PROMPT_BASE}

${storyContext}

**INSTRUCCIONES PARA IMAGEN DE CIERRE:**
Genera una imagen de CIERRE del cuento que muestre ${contentSummary.characterCount > 1 ? 'a los personajes principales' : `al ${contentSummary.character}`} de ESPALDAS caminando hacia el horizonte. ${contentSummary.characterCount > 1 ? 'Los personajes deben ir TOMADOS DE LA MANO, mostrando su vínculo y compañerismo.' : 'El personaje camina solo pero con confianza hacia su futuro.'} 

La composición debe ser:
- Vista posterior (back view) mostrando la espalda del/los personaje(s)
- Caminando hacia un horizonte luminoso y prometedor
- El escenario debe reflejar el ${contentSummary.setting} del cuento
- Ambiente cálido de despedida y esperanza
- Transmite un sentimiento de conclusión, paz y nuevas aventuras por venir

La imagen debe mantener PERFECTAMENTE el estilo visual y las características físicas del/los personaje(s) establecidas en las imágenes anteriores. Esta es la despedida visual del cuento, debe ser emotiva y esperanzadora.

${baseStyle}`
    };
  }

  /**
   * Extracts key story elements for consistent image generation
   */
  private static extractStoryElements(content: string): { character: string; setting: string; mood: string; characterCount: number } {
    // Simple extraction logic - can be enhanced with AI analysis later
    const lowercaseContent = content.toLowerCase();
    
    // Detect character count (for closing image)
    let characterCount = 1;
    const multipleCharacterIndicators = ['dos personajes', 'ambos', 'juntos', 'acompañ', 'amigos', 'hermanos', 'compañeros'];
    if (multipleCharacterIndicators.some(indicator => lowercaseContent.includes(indicator))) {
      characterCount = 2;
    }
    
    // Detect character types
    let character = 'personaje principal';
    if (lowercaseContent.includes('niño') || lowercaseContent.includes('niña')) character = 'niño protagonista';
    else if (lowercaseContent.includes('animal')) character = 'animal protagonista';
    else if (lowercaseContent.includes('dragón')) character = 'dragón amigable';
    else if (lowercaseContent.includes('princesa')) character = 'princesa';
    else if (lowercaseContent.includes('príncipe')) character = 'príncipe';
    
    // Detect settings
    let setting = 'lugar mágico';
    if (lowercaseContent.includes('bosque')) setting = 'bosque encantado';
    else if (lowercaseContent.includes('jardín')) setting = 'jardín colorido';
    else if (lowercaseContent.includes('casa')) setting = 'hogar acogedor';
    else if (lowercaseContent.includes('escuela')) setting = 'escuela';
    else if (lowercaseContent.includes('parque')) setting = 'parque';
    
    // Detect mood
    let mood = 'atmósfera de aventura y alegría';
    if (lowercaseContent.includes('feliz') || lowercaseContent.includes('alegría')) mood = 'ambiente alegre y festivo';
    else if (lowercaseContent.includes('misterio')) mood = 'atmósfera misteriosa pero segura';
    else if (lowercaseContent.includes('amistad')) mood = 'ambiente cálido de amistad';
    
    return { character, setting, mood, characterCount };
  }

  /**
   * Creates specific prompts for each image type (legacy method, keep for compatibility)
   * CHARACTER is generated first to establish visual consistency for scenes
   */
  private static createImagePrompts(title: string, content: string): Partial<Record<ImageType, string>> {
    const baseContext = `**Cuento:**
Título: ${title}
Cuento: ${content}`;

    return {
    [IMAGES_TYPE.COVER]: `${SYSTEM_PROMPT_BASE}

${baseContext}

Genera una imagen de PORTADA que capture la esencia del cuento. Debe incluir el título de manera artística y elementos visuales que representen la historia principal, manteniendo la misma estética del personaje principal. Estilo acuarela tradicional de cuento infantil.`,

      [IMAGES_TYPE.SCENE_1]: `${SYSTEM_PROMPT_BASE}

${baseContext}

Genera una imagen de la PRIMERA ESCENA más importante del cuento, donde el PERSONAJE PRINCIPAL debe ser el elemento central de la composición. Debe mostrar un momento clave de la historia con el protagonista en acción, manteniendo las características visuales establecidas del personaje. Estilo acuarela tradicional de cuento infantil.`,

      [IMAGES_TYPE.SCENE_2]: `${SYSTEM_PROMPT_BASE}

${baseContext}

Genera una imagen de la SEGUNDA ESCENA más importante del cuento, donde el PERSONAJE PRINCIPAL debe ser prominente en la escena. Debe representar otro momento crucial diferente al anterior, mostrando al protagonista en una situación distinta pero manteniendo continuidad visual y las características del personaje establecidas. Estilo acuarela tradicional de cuento infantil.`
    };
  }

  /**
   * Generates a single image with fallback logic - does not stop PDF generation if images fail
   */
  private static async generateSingleImageWithFallback(
    params: GenerateSingleImageParams
  ): Promise<{ success: boolean; image?: GeneratedImage; error?: string }> {
    const {
      imageType,
      prompt,
      storyId,
      chapterId,
      providerConfig,
      desiredAspectRatio,
      logPrefix = '[ImageGeneration]',
    } = params;

    try {
      console.log(`${logPrefix} Attempting to generate ${imageType}...`);
      
      // Try to generate the image
      const result = await this.generateSingleImage({
        imageType,
        prompt,
        storyId,
        chapterId,
        providerConfig,
        desiredAspectRatio,
        logPrefix,
      });
      
      if (result.success) {
        return result;
      }
      
      // If generation failed, log and return fallback information
      console.warn(`${logPrefix} ⚠️ Image generation failed for ${imageType}, PDF will use fallback styling`);
      return {
        success: false,
        error: `${imageType} generation failed: ${result.error}. PDF will use white background.`
      };
      
    } catch (error) {
      console.error(`${logPrefix} ❌ Critical error generating ${imageType}:`, error);
      return {
        success: false,
        error: `Critical error in ${imageType}: ${error instanceof Error ? error.message : 'Unknown error'}. PDF will use fallback.`
      };
    }
  }

  /**
   * Generates a single image and uploads it to Supabase (original method)
   */
  private static async generateSingleImage(
    params: GenerateSingleImageParams
  ): Promise<{ success: boolean; image?: GeneratedImage; error?: string }> {
    const {
      imageType,
      prompt,
      storyId,
      chapterId,
      providerConfig,
      desiredAspectRatio,
      logPrefix = '[ImageGeneration]',
    } = params;

    try {
      console.log(`${logPrefix} Generating ${imageType} image...`);

      const edgeResponse = await this.callGenerateImageEdge({
        prompt,
        storyId,
        chapterId: typeof chapterId === 'string' ? chapterId : chapterId.toString(),
        imageType,
        desiredAspectRatio,
        providerConfig,
      });

      const metadata = this.composeGeneratedMetadata(edgeResponse, {
        storyId,
        chapterId: typeof chapterId === 'string' ? chapterId : chapterId.toString(),
        imageType,
      });

      if (metadata.requestedAspectRatio || metadata.effectiveAspectRatio) {
        const requested = metadata.requestedAspectRatio ?? desiredAspectRatio;
        const effective = metadata.effectiveAspectRatio ?? requested;
        console.log(
          `${logPrefix} Ratio solicitado ${requested} → efectivo ${effective}${metadata.fallbackUsed ? ' (fallback)' : ''}`,
        );
      }

      if (edgeResponse.publicUrl) {
        console.log(`${logPrefix} Successfully generated and uploaded ${imageType}`);
        return {
          success: true,
          image: {
            type: imageType,
            url: edgeResponse.publicUrl,
            prompt,
            metadata,
          },
        };
      }

      // Fallback: if server-side upload not available, do legacy path using returned base64
      const imageBase64 = edgeResponse.imageBase64;
      if (!imageBase64) {
        throw new Error(edgeResponse.error || 'No image data returned from image service');
      }

      const uploadResult = await this.uploadImageToSupabase(
        imageBase64,
        imageType,
        storyId,
        chapterId,
        {
          providerUsed: metadata.providerUsed,
          mimeType: metadata.mimeType ?? undefined,
        },
      );
      if (!uploadResult.success) throw new Error(`Upload failed: ${uploadResult.error}`);

      const mergedMetadata: GeneratedImageMetadata = {
        ...metadata,
        storagePath: uploadResult.storagePath ?? metadata.storagePath ?? null,
        mimeType: uploadResult.mimeType ?? metadata.mimeType ?? null,
      };

      console.log(`${logPrefix} Successfully generated and uploaded ${imageType} (fallback upload)`);
      return {
        success: true,
        image: {
          type: imageType,
          url: uploadResult.publicUrl!,
          prompt,
          base64: imageBase64,
          metadata: mergedMetadata,
        },
      };
      
    } catch (error) {
      console.error(`${logPrefix} Error generating ${imageType}:`, error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Error desconocido'
      };
    }
  }

  /**
   * Calls secure Edge Function to generate image using OpenAI DALL-E
   * @param prompt Image generation prompt
   * @returns Promise<string | null> Base64 image data or null if failed
   */
  private static async callGenerateImageEdge(params: {
    prompt: string;
    storyId?: string;
    chapterId?: string;
    imageType?: ImageType;
    desiredAspectRatio: string;
    providerConfig: ImageProviderConfig;
  }): Promise<EdgeFunctionResponse> {
    try {
      console.log('[ImageGeneration] Calling generate-image Edge Function...');
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), params.providerConfig.providerTimeoutMs + 5000);
      try {
        const { data, error } = await supabase.functions.invoke<EdgeFunctionResponse & { success?: boolean; error?: string }>('generate-image', {
          body: {
            prompt: params.prompt.trim(),
            model: params.providerConfig.openAiModel,
            quality: params.providerConfig.openAiQuality,
            style: params.providerConfig.openAiStyle,
            background: params.providerConfig.background,
            desiredAspectRatio: params.desiredAspectRatio,
            storyId: params.storyId,
            chapterId: params.chapterId ?? null,
            imageType: params.imageType,
            providerTimeoutMs: params.providerConfig.providerTimeoutMs,
          },
          signal: controller.signal as unknown as AbortSignal
        } as any);
        clearTimeout(timeout);
        if (error) {
          const errorMessage = error.message || String(error);
          if (errorMessage.includes('content_policy')) {
            throw new Error('El contenido no cumple con las políticas de seguridad');
          } else if (errorMessage.includes('billing')) {
            throw new Error('Error de facturación del servicio de imágenes');
          } else if (errorMessage.includes('rate_limit')) {
            throw new Error('Se excedió el límite de solicitudes. Intenta de nuevo más tarde');
          }
          throw new Error(`Error en Edge Function: ${errorMessage}`);
        }
        if (data?.success === false) {
          throw new Error(data?.error || 'Edge Function returned an error response');
        }
        return {
          success: data?.success,
          publicUrl: data?.publicUrl ?? null,
          storagePath: data?.storagePath ?? null,
          metadata: data?.metadata ?? null,
          providerUsed: data?.providerUsed,
          fallbackUsed: data?.fallbackUsed,
          latencyMs: data?.latencyMs,
          imageBase64: data?.imageBase64 ?? null,
          error: data?.error,
        };
      } catch (invokeError) {
        clearTimeout(timeout);
        if (invokeError instanceof Error && invokeError.name === 'AbortError') {
          throw new Error('Tiempo de espera agotado en generación de imagen');
        }
        throw invokeError;
      }
    } catch (error) {
      console.error('[ImageGeneration] Edge invocation error:', error);
      throw new Error(error instanceof Error ? error.message : 'Error desconocido al invocar la función');
    }
  }

  private static composeGeneratedMetadata(
    response: EdgeFunctionResponse,
    context: { storyId?: string; chapterId?: string; imageType?: ImageType }
  ): GeneratedImageMetadata {
    const metadata = response.metadata ?? undefined;
    return {
      providerUsed: metadata?.providerUsed ?? response.providerUsed ?? undefined,
      fallbackUsed: metadata?.fallbackUsed ?? response.fallbackUsed ?? undefined,
      latencyMs: metadata?.latencyMs ?? response.latencyMs ?? undefined,
      requestedAspectRatio: metadata?.requestedAspectRatio ?? undefined,
      effectiveAspectRatio: metadata?.effectiveAspectRatio ?? undefined,
      requestSize: metadata?.requestSize ?? undefined,
      originalResolution: metadata?.originalResolution ?? undefined,
      finalResolution: metadata?.finalResolution ?? undefined,
      resizedFrom: metadata?.resizedFrom ?? undefined,
      resizedTo: metadata?.resizedTo ?? undefined,
      mimeType: metadata?.mimeType ?? undefined,
      storagePath: metadata?.storagePath ?? response.storagePath ?? undefined,
      storyId: context.storyId ?? metadata?.storyId ?? undefined,
      chapterId: context.chapterId ?? metadata?.chapterId ?? undefined,
      imageType: context.imageType ?? metadata?.imageType ?? undefined,
    };
  }

  /**
   * Uploads generated image to Supabase storage via Edge Function
   */
  private static async uploadImageToSupabase(
    imageBase64: string, 
    imageType: ImageType, 
    storyId: string, 
    chapterId: string | number,
    metadata?: { providerUsed?: string; mimeType?: string }
  ): Promise<{ success: boolean; publicUrl?: string; storagePath?: string; mimeType?: string; error?: string }> {
    try {
      console.log(`[ImageGeneration] Uploading ${imageType} via Edge Function...`);

      // Usar supabase.functions.invoke para mejor integración
      const { data: functionResponse, error: functionError } = await supabase.functions.invoke(
        'upload-story-image',
        {
          body: {
            imageBase64,
            imageType,
            storyId,
            chapterId: chapterId.toString(),
            mimeType: metadata?.mimeType,
            providerUsed: metadata?.providerUsed,
          }
        }
      );

      if (functionError) {
        console.error('[ImageGeneration] Function error:', functionError);
        throw new Error(`Function error: ${functionError.message}`);
      }

      if (!functionResponse?.success) {
        const errorMsg = functionResponse?.error || functionResponse?.details || 'Unknown upload error';
        throw new Error(`Upload failed: ${errorMsg}`);
      }

      console.log(`[ImageGeneration] Successfully uploaded ${imageType}:`, functionResponse.publicUrl);

      return {
        success: true,
        publicUrl: functionResponse.publicUrl,
        storagePath: functionResponse.storagePath,
        mimeType: functionResponse.mimeType,
      };
      
    } catch (error) {
      console.error('[ImageGeneration] Upload error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Error de subida'
      };
    }
  }
} 
